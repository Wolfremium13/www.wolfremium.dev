---
title: "游떂 Haseando y optimizando en pandas"
date: "2023-02-20"
preview: "/assets/blog/hasing-and-optimizing-on-pandas/running-cat.gif"
tags:
  - "游냀 Python"
  - "游 Data Engineering"
---

En primer lugar he de darle las gracias a Mario Pinto por alentarme a escribir
este post, recientemente nos hemos encontrado un c칩digo "mejorable" el cu치l ya
ten칤a una base de tests. El caso era que deb칤amos de remover de nuestros datos
una serie de filas usando pandas en base a un conjunto de columnas, un filtro
compuesto por as칤 decirlo. El caso era que el c칩digo que ten칤amos no estaba muy
[vectorizado](https://pythonspeed.com/articles/pandas-vectorization/) para
trabajar con datos. Veamos la tabla por la que hay que filtrar:

**Tabla de filtrado**

```markdown
| ID  | year | category |
| --- | ---- | -------- |
| A1  | 1    | A        |
| B2  | 2    | B        |
| ... | ...  | ...      |
```

La idea aqu칤 era simplificar el c칩digo lo m치ximo posible tanto el proceso como
la complejidad del c칩digo por lo que se nos ocurri칩 generar una nueva columna
con el valor [hash](https://es.wikipedia.org/wiki/Funci%C3%B3n_hash) siendo la
suma de todos los elementos a filtrar. Nos dimos cuenta r치pidamente de que
pandas necesita usar su propia funci칩n de hashing, ya que usar la implementaci칩n
de hash de python requer칤a un `apply` o un `applymap`.

**Ejemplo con apply**

```python
df['hash'] = df.apply(lambda x: hash(x['ID'] + x['year'] + x['category']), axis = 1)
```

**Ejemplo con sin apply**

```python
df['hash'] = pd.util.hash_array(
  df['ID'].to_numpy() + df['year'].to_numpy() + df['category'].to_numpy()
)
```

Usamos el `.to_numpy()` para convertir el valor de la `pd.Series` en un array
que contiene los 3 valores `[ID, year, category]` para luego generar un n칰mero
칰nico en base a esos valores.

> Si usas
> [pandas.util.hash_pandas_object](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.util.hash_pandas_object.html#pandas-util-hash-pandas-object)
> recuerda que hace un hash sobre el 칤ndice del objeto en cuesti칩n por lo que no
> nos sirve para comparar con un objeto con diferente 칤ndice en otro dataframe.

Ahora si ya tenemos enn la tabla de filtrado la nueva columna.

**Tabla de filtrado**

```markdown
| ID  | year | category | hash |
| --- | ---- | -------- | ---- |
| A1  | 1    | A        | 101  |
| B2  | 2    | B        | 110  |
| ... | ...  | ...      | ...  |
```

La funci칩n quedar칤a a침adirla a los datos:

**Tabla de datos**

```markdown
| ID  | year | category | hash | more_columns... |
| --- | ---- | -------- | ---- | --------------- |
| A1  | 1    | A        | 101  | ...             |
| B2  | 2    | B        | 110  | ...             |
| ... | ...  | ...      | ...  | ...             |
```

Y ahora solo quedar칤a filtrar para quedarnos con aquellos hashes que no
aparezcan en la tabla de filtrado:

**Filtrado de los datos**

```python
are_not_on_filter_table = (~data['hash'].isin(filter_table['hash']))
filtered = data[are_not_on_filter_table].drop(columns=['hash'])
```

## Conclusi칩n

Este es un caso que se puede resolver de muchas maneras, en este caso hemos
intentado resolverlo de una manera con pocas l칤neas de c칩digo y que no se usase
`apply` en cuesti칩n de rendimiento va bastante bien y es simple de a침adir o
quitar columnas para filtrar. Si por ejemplo hubiesen muchos valores en la tabla
de filtrado el `.isin()` tendr칤a que comprobar para todos los buscar por las
**N** filas de la tabla de filtrado, probablemente haya soluciones mejores como
`merge`.
